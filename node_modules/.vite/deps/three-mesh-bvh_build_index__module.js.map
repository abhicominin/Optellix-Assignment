{
  "version": 3,
  "sources": ["../../three-mesh-bvh/src/core/Constants.js", "../../three-mesh-bvh/src/core/MeshBVHNode.js", "../../three-mesh-bvh/src/utils/ArrayBoxUtilities.js", "../../three-mesh-bvh/src/core/buildFunctions.js", "../../three-mesh-bvh/src/math/SeparatingAxisBounds.js", "../../three-mesh-bvh/src/math/MathUtilities.js", "../../three-mesh-bvh/src/math/ExtendedTriangle.js", "../../three-mesh-bvh/src/math/OrientedBox.js", "../../three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js", "../../three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js", "../../three-mesh-bvh/src/utils/TriangleUtilities.js", "../../three-mesh-bvh/src/utils/PrimitivePool.js", "../../three-mesh-bvh/src/core/nodeBufferFunctions.js", "../../three-mesh-bvh/src/core/castFunctions.js", "../../three-mesh-bvh/src/core/MeshBVH.js", "../../three-mesh-bvh/src/objects/MeshBVHVisualizer.js", "../../three-mesh-bvh/src/debug/Debug.js", "../../three-mesh-bvh/src/utils/ExtensionUtilities.js", "../../three-mesh-bvh/src/gpu/VertexAttributeTexture.js", "../../three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js", "../../three-mesh-bvh/src/gpu/shaderFunctions.js", "../../three-mesh-bvh/src/utils/StaticGeometryGenerator.js"],
  "sourcesContent": ["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n", "export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n", "export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n", "import { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport {\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\n} from './Constants.js';\n\nfunction ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tlet index;\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo, fullBounds ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai, bi, ci;\n\n\t\tif ( normalized ) {\n\n\t\t\tai = index[ tri3 + 0 ];\n\t\t\tbi = index[ tri3 + 1 ];\n\t\t\tci = index[ tri3 + 2 ];\n\n\t\t} else {\n\n\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo, options );\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = geo.index.count / 3;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n", "import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n", "import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n", "import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst DIST_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < DIST_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points1 = this.points;\n\t\t\tlet found1 = false;\n\t\t\tlet count1 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir1 );\n\n\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\n\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge1.copy( edge );\n\t\t\t\t\tcount1 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount1 ++;\n\t\t\t\t\tif ( found1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound1 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst points2 = other.points;\n\t\t\tlet found2 = false;\n\t\t\tlet count2 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir2 );\n\n\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\n\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge2.copy( edge );\n\t\t\t\t\tcount2 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount2 ++;\n\t\t\t\t\tif ( found2 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound2 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n", "import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n", "import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst vA = /* @__PURE__ */ new Vector3();\nconst vB = /* @__PURE__ */ new Vector3();\nconst vC = /* @__PURE__ */ new Vector3();\n\nconst uvA = /* @__PURE__ */ new Vector2();\nconst uvB = /* @__PURE__ */ new Vector2();\nconst uvC = /* @__PURE__ */ new Vector2();\n\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\n\n\tvA.fromBufferAttribute( position, a );\n\tvB.fromBufferAttribute( position, b );\n\tvC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tconst a = geo.index.getX( triOffset );\n\tconst b = geo.index.getX( triOffset + 1 );\n\tconst c = geo.index.getX( triOffset + 2 );\n\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n", "import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n", "\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i );\n\t\ti1 = index.getX( i + 1 );\n\t\ti2 = index.getX( i + 2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nexport function iterateOverTriangles(\n\toffset,\n\tcount,\n\tgeometry,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst index = geometry.index;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tsetTriangle( triangle, i * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n", "export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n", "export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n", "import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\n\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\n\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [ 'x', 'y', 'z' ];\n\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport const shapecast = ( function () {\n\n\tlet _box1, _box2;\n\tconst boxStack = [];\n\tconst boxPool = new PrimitivePool( () => new Box3() );\n\n\treturn function shapecast( ...args ) {\n\n\t\t_box1 = boxPool.getPrimitive();\n\t\t_box2 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1, _box2 );\n\n\t\tconst result = shapecastTraverse( ...args );\n\n\t\tboxPool.releasePrimitive( _box1 );\n\t\tboxPool.releasePrimitive( _box2 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2 = boxStack[ length - 1 ];\n\t\t\t_box1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tbox2 = _box2;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n} )();\n\nexport const intersectsGeometry = ( function () {\n\n\tconst triangle = new ExtendedTriangle();\n\tconst triangle2 = new ExtendedTriangle();\n\tconst invertedMat = new Matrix4();\n\n\tconst obb = new OrientedBox();\n\tconst obb2 = new OrientedBox();\n\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, boundingBox );\n\treturn ray.intersectBox( boundingBox, target );\n\n}\n\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer( buffer ) {\n\n\tif ( _prevBuffer ) {\n\n\t\tbufferStack.push( _prevBuffer );\n\n\t}\n\n\t_prevBuffer = buffer;\n\t_float32Array = new Float32Array( buffer );\n\t_uint16Array = new Uint16Array( buffer );\n\t_uint32Array = new Uint32Array( buffer );\n\n}\n\nexport function clearBuffer() {\n\n\t_prevBuffer = null;\n\t_float32Array = null;\n\t_uint16Array = null;\n\t_uint32Array = null;\n\n\tif ( bufferStack.length ) {\n\n\t\tsetBuffer( bufferStack.pop() );\n\n\t}\n\n}\n", "import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\totherBvh.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n", "import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nclass MeshBVHRootVisualizer extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootVisualizer';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.mesh = mesh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHVisualizer extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh, depth = 10 ) {\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHVisualizer';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst bvh = this.mesh.geometry.boundsTree;\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.depth = this.depth;\n\t\t\troot.mesh = this.mesh;\n\t\t\troot.displayParents = this.displayParents;\n\t\t\troot.displayEdges = this.displayEdges;\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tthis.position.copy( this.mesh.position );\n\t\tthis.rotation.copy( this.mesh.rotation );\n\t\tthis.scale.copy( this.mesh.scale );\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { MeshBVHVisualizer };\n", "import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\n\nconst _box1 = /* @__PURE__ */ new Box3();\nconst _box2 = /* @__PURE__ */ new Box3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getPrimitiveSize( el ) {\n\n\tswitch ( typeof el ) {\n\n\t\tcase 'number':\n\t\t\treturn 8;\n\t\tcase 'string':\n\t\t\treturn el.length * 2;\n\t\tcase 'boolean':\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\n\t}\n\n}\n\nfunction isTypedArray( arr ) {\n\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\treturn regex.test( arr.constructor.name );\n\n}\n\nfunction getRootExtremes( bvh, group ) {\n\n\tconst result = {\n\t\tnodeCount: 0,\n\t\tleafNodeCount: 0,\n\n\t\tdepth: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\ttris: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tsplits: [ 0, 0, 0 ],\n\t\tsurfaceAreaScore: 0,\n\t};\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\tresult.nodeCount ++;\n\t\tif ( isLeaf ) {\n\n\t\t\tresult.leafNodeCount ++;\n\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t} else {\n\n\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t}\n\n\t}, group );\n\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\tif ( result.tris.min === Infinity ) {\n\n\t\tresult.tris.min = 0;\n\t\tresult.tris.max = 0;\n\n\t}\n\n\tif ( result.depth.min === Infinity ) {\n\n\t\tresult.depth.min = 0;\n\t\tresult.depth.max = 0;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getBVHExtremes( bvh ) {\n\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n}\n\nfunction estimateMemoryInBytes( obj ) {\n\n\tconst traversed = new Set();\n\tconst stack = [ obj ];\n\tlet bytes = 0;\n\n\twhile ( stack.length ) {\n\n\t\tconst curr = stack.pop();\n\t\tif ( traversed.has( curr ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\ttraversed.add( curr );\n\n\t\tfor ( let key in curr ) {\n\n\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\tconst value = curr[ key ];\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\treturn bytes;\n\n}\n\nfunction validateBounds( bvh ) {\n\n\tconst geometry = bvh.geometry;\n\tconst depthStack = [];\n\tconst index = geometry.index;\n\tconst position = geometry.getAttribute( 'position' );\n\tlet passes = true;\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tdepth,\n\t\t\tisLeaf,\n\t\t\tboundingData,\n\t\t\toffset,\n\t\t\tcount,\n\t\t};\n\t\tdepthStack[ depth ] = info;\n\n\t\tarrayToBox( 0, boundingData, _box1 );\n\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\tif ( isLeaf ) {\n\n\t\t\t// check triangles\n\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\tconst i0 = index.getX( i );\n\t\t\t\tconst i1 = index.getX( i + 1 );\n\t\t\t\tconst i2 = index.getX( i + 2 );\n\n\t\t\t\tlet isContained;\n\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\t// check if my bounds fit in my parents\n\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t} );\n\n\treturn passes;\n\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure( bvh ) {\n\n\tconst depthStack = [];\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\n\t\t};\n\n\t\tif ( isLeaf ) {\n\n\t\t\tinfo.count = count;\n\t\t\tinfo.offset = offset;\n\n\t\t} else {\n\n\t\t\tinfo.left = null;\n\t\t\tinfo.right = null;\n\n\t\t}\n\n\t\tdepthStack[ depth ] = info;\n\n\t\t// traversal hits the left then right node\n\t\tconst parent = depthStack[ depth - 1 ];\n\t\tif ( parent ) {\n\n\t\t\tif ( parent.left === null ) {\n\n\t\t\t\tparent.left = info;\n\n\t\t\t} else {\n\n\t\t\t\tparent.right = info;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn depthStack[ 0 ];\n\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\n", "import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n", "import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n", "import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/nodeBufferFunctions.js';\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.autoDispose = true;\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.index.updateFrom( geometry.index );\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n", "// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const shaderStructs = /* glsl */`\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n\nexport const shaderIntersectFunction = /* glsl */`\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\n// Raycasting\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n\n// Distance to Point\nexport const shaderDistanceFunction = /* glsl */`\n\nfloat dot2( in vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\tBVH bvh, vec3 point, uint offset, uint count, float closestDistanceSquared,\n\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord, out float side, out vec3 outPoint\n) {\n\n\tbool found = false;\n\tuvec3 localIndices;\n\tvec3 localBarycoord;\n\tvec3 localNormal;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\nfloat bvhClosestPointToPoint(\n\tBVH bvh, vec3 point,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh, point, offset, count, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n", "import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index;\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.boneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n"],
  "mappings": "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",
  "names": ["leftBounds", "areIntersecting", "closestPointLineToLine", "temp1", "temp2", "closestPointsSegmentToSegment", "sphereIntersectTriangle", "xyzFields", "ray", "boundingBox", "_box1", "_box2", "shapecast", "nodeIndex32", "nodeIndex16", "uint16Array", "uint32Array", "temp", "obb", "obb2", "intersectsGeometry", "byteOffset", "box", "contained", "root", "offset"]
}
